Datatypes:
int, char, varchar, double, decimal

double(7,2).... 7 bits for integers and 2 bits for decimals
int(3).... 3 digits

char and varchar
char(10)... tom... 3 bits are used remaining 7 bits cannot be reused they are wasted
varchar(10)...tom... here remaining 7 bits can be reused


DDL 
DAta definition language
All ddl commands are auto commit
create,drop,alter,truncate

CREATE TABLE  Employees(
		Eid INTEGER(3) PRIMARY KEY ,
		 EName VARCHAR(20) NOT NULL,
		  Salary DOUBLE,
                  Comm  DOUBLE ,
		  Job  VARCHAR(20),
		  DOJ   DATE
);

Alter has three options we can add,modify and drop:


ALTER TABLE Employees ADD Mid Int(3);

ALTER TABLE Employees MODIFY Ename varchar(30);

ALTER TABLE Employees DROP column mid;  // it can also be used to drop constraints

===================================================

DML: DAta manipulattion language
Insert,Update,Delete
All dml are also auto commit but we can control them using commit and rollback

INSERT:

INSERT INTO Employees values(101,'King',50000,null,'President','2021-09-12',null);

INSERT INTO Employees values(102,'Smith',30000,null,'Manager','2021-12-01',101);

INSERT INTO Employees values(103,'ford',32000,null,'Manager','2022-05-14',101);

INSERT INTO Employees values(104,'Adam',22000,1500,'Developer','2022-07-22',102),
(105,'Tom',24000,1000,'Developer','2022-02-14',102);

INSERT INTO Employees values(106,'Ravi',20000,3000,'Tester','2022-08-21',103),
(107,'Jerry',19000,3000,'Tester','2022-11-14',103);

INSERT INTO Employees values(108,'Raju',7000,2000,'Clerk',current_date,101);


UPDATE: 

UPDATE Employees SET Salary=37000 where Eid=102;


DELETE:

DELETE FROM Employees where eid=101;

========================================================
TCL: Transaction Control Language
commit, rollback, savepoint

START TRANSACTION;

INSERT INTO Employees(eid,ename,salary) values(109,'babu',5000); //here remaining values are implicitly null

select * from Employees;

update Employees set job='salesman' where eid=109;

rollback;  // transaction is 0 percent completed or completely undone

commit;  // transaction is 100 percent completed or completely done as there are no partial transactions.

NOTE: After commit we cannot do rollback

Start Transaction
insert1
insert2
insert3

savepoint s1;

update1
update2
update3

rollback s1;  //till s1 it will rollback all insert will remain untouched

commit; // now this commit will commit all the insert but not updates

=========================================================
DCL: Data Control Language
Grant, Revoke
Granting and revoking permission by admin to the user

grant select,update,delete on Employees to viru;
grant all on Employees to viru
REVOKE SELECT, INSERT, DELETE, UPDATE ON Users FROM 'Amit'@'localhost';

=========================================================


DQL/DRL: Data Query/Retreival Language



select * from employees;  //here * is projection
select eid,ename,salary from employees where eid>101;  // here eid,ename,salary is projection and where eid>101 is the filter/selection

In realtime it is always recommended to write all columns in projection instead of *

select eid,ename,salary,comm,job,doj,mid from employees where salary>25000;

select eid,ename,salary,comm,job,doj,mid from employees where doj='2021-09-12';



How to deal with null values........................ 
null is not nothing it is a unique value whis is in memory which is auto generated by system so every null value is different which is why it cannot be compared it can only be verified

select * from employees where comm IS null;

select * from employees where comm IS NOT null;


=======================================================================

JOINS:
In sql joins are to fetch data from multiple tables.

It is possible with the help of a common columns in both table 

Note: Common column with same datatypes and values name dont need to be same

Types of joins:
1.Equi joins (Inner joins, natural joins,..)
2.Non equi joins
3.Self joins
4.Outer joins

create table dept(dno int(2) , dname varchar(20), Location varchar(30),Constraints DEP_DNO_PK primary key(dno));

//alter table dept drop constraint DEP_DNO_PK;

Ways in which we can establish relation between two tables:
primary key--> foreign key
unique key--> foreign key

alter table employees add dno int(2) references dept(dno);

insert into dept values(10,'Development','Hyderabad');
insert into dept values(20,'Testing','Chennai');
insert into dept values(30,'Operation','Pune');
insert into dept values(40,'Research','Banglore');
insert into dept values(50,'Sales','Mumbai');

update employees set dno=10 where eid=101 or eid=102 or eid=103 or eid=104 or eid=105;
update employees set dno=10 where eid in (101,102,104,105);
update employees set dno=20 where eid in (103,106,107);
update employees set dno=30 where eid=108;
update employees set dno=40 where eid=109;

insert into employees values(110,'javeed',0,5000,'Intern',current_date,101,null);


JOINS==========

EQUI JOIN

select eid,ename,salary,job,d.dno,dname,location from employees e,dept d where e.dno=d.dno;
   
NOTE:a,b or b,a is same and e and d are aliases and if we dont use where clause we will get cartesian product which is not useful. The . is known as qualifier and we dont have to use aliases if column names are different.

INNER JOIN
select eid,ename,salary,dept.dno,dname,location from employees e inner join dept d where e.dno=d.dno;

NATURAL JOIN
select eid,ename,salary,job,dno,dname from employees natural join dept;



2. NON EQUI JOIN
select eid,ename,salary,job,d.dno,dname,location from employees e,dept d where e.dno!=d.dno;




3. SELF JOIN
We consider an imaginary table according to our need

Trying to find emps who manage at least someone


select e.eid,e.ename,e.salary, m.eid,m.ename,m.salary,m.mid from employees e, employees m where e.mid=m.eid;


4. OUTER JOIN

LEFT
select eid,ename,job,salary,d.dno,dname,location from employees e left outer join dept d on e.dno=d.dno; 

RIGHT
select eid,ename,job,salary,d.dno,dname,location from employees e right outer join dept d on e.dno=d.dno;

FULL OUTER JOIN

select eid,ename,job,salary,d.dno,dname,location from employees e left outer join dept d on e.dno=d.dno 
UNION
select eid,ename,job,salary,d.dno,dname,location from employees e right outer join dept d on e.dno=d.dno;


======================================================
SUBQUERIES

It is nothing but inner query or nested query.
The innermost query gets executes first and it's output is passed as input to outer query.
When to use subquery:
1.When condition is known but don't know exact value.
2. When we want to fetch data from one table but required condition exists in another table.

Note: Whatever we can do with subqueries same can be performed using joins also.

Ex. display salary of those employees whose salary is greater than tom.............

select * from employees where salary>(select salary from employees where ename='tom');

Ex.emps who join after javeed................

select * from employees where doj<(select doj from employees where ename='javeed');


Single row operators:....................
=, !=, >, <

Multi row operators:.....................
IN, NOT IN

details of emps working in hyderabad...................

select * from employees where dno in (select dno from dept where location ='Hyderabad');

Hyderabad or Pune.....................

select * from employees where dno in (select dno from dept where location in('Hyderabad','Pune'));

select * from employees where dno in (select dno from dept where location ='Hyderabad' or location='Pune');



EQUALS TO ANY // works like in......................

select * from employees where dno =ANY (select dno from dept where location ='Hyderabad' or location='Pune');


Greater than any/less than any.........................

select * from employees where salary >ANY (select salary from employees where ename in('Tom','javeed'));

Greater than all and less than all // Equal to all does not work..........

select * from employees where salary >ALL (select salary from employees where ename in('Tom','javeed'));


For getting data from multiple tables..............................
select eid,ename,dname,location from employees e,dept d where e.dno=d.dno;

doing it using subqueries becomes very complex

select * from (select eid,ename,salary from employees) e; //here e is an imaginary table with 3 columns


=====================================================
AGGREGATE FUNCTIONS/ GROUP FUNCTIONS

1.SUM
2.AVG
3.COUNT
4.MIN
5.MAX

select sum(salary) from employees; 

select dno,sum(salary) from employees group by dno; 

Arithmetic operation with null gives null.............
select ename,salary+comm from employees;

We can sort this using IFNULL function...................
select ename,salary+ IFNULL(comm,0) total from employees;

NOTE: Group functions do not consider null values but group by functions consider null values  AND the columns mentioned in  group by are available for projection.


select count(comm) from employees;

select min(salary) from employees;
select max(salary) from employees;
select min(doj) from employees;


select ename,salary,(select sum(salary) from employees) total from employees;
 
select ename,salary,(select sum(salary) from employees)-salary budget_left from employees;


dml and select(subqueries, joins, aggregate func,string func,date func)
